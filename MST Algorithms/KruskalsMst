#include <stdio.h>
#define CAP 50 // Maximum on noof vertices

typedef struct Graph
{
	int noof_v;
	int noof_e;
	int mat[CAP][CAP];
	int edges[CAP * CAP][2];
	int weights[CAP * CAP];
	
} Graph;


#define swap(one, two)\
	do{\
		int temp = one;\
		one = two;\
		two = temp;\
	}while (0)
	
	
void mat_read(int rows, int cols, int mat[CAP][CAP])
{
	int i, j;
	for (i = 0; i < rows; ++i)
	for (j = 0; j < cols; ++j)
	{
		scanf("%d", &mat[i][j]);
	}
}	

void edges_and_weights_print(int noof_e, int edges[CAP*CAP][2], int weights[CAP*CAP])
{
	int i;
	for (i = 0; i < noof_e; ++i)
	{
		printf("(%d, %d, %d) ", edges[i][0], edges[i][1], weights[i]);
	}
	printf("\n");
}	

void mst_print(int noof_v, int mst[CAP*CAP][2])
{
	int i;
	for (i = 0; i < noof_v; ++i)
	{
		printf("(%d, %d) ", mst[i][0], mst[i][1]);
	}
	printf("\n");
}	

////////////////////////////////////////////////

int d_find(int noof_v, int* d_arr, int ele)
{
	int parent = d_arr[ele];
	if (parent < 0) return ele;
	
	while (d_arr[parent] >= 0)
	{
		parent = d_arr[parent];
	}
	
	return parent;
}

void d_union(int noof_v, int* d_arr, int anc1, int anc2)
{
	if (d_arr[anc1] <= d_arr[anc2])
	{
		d_arr[anc1] += d_arr[anc2];
		d_arr[anc2] = anc1;
	}
	else
	{
		d_arr[anc2] += d_arr[anc1];
		d_arr[anc1] = anc2;
	}
}

void d_construct(int noof_v, int* d_arr)
{
	for (int i = 1; i < noof_v + 1; ++i)
	{
		d_arr[i] = -1;
	}
}
//////////////////////////////////////////////////////////


int partition_rpiv(int* weights, int edges[CAP*CAP][2], int left, int right) 
{
	int pivot = weights[right];
	int i = left - 1, j;
	
	for (j = left; j < right; ++j)
	{
		if (weights[j] < pivot)
		{
			i++;
			swap(weights[i], weights[j]);
			swap(edges[i][0], edges[j][0]);
			swap(edges[i][1], edges[j][1]);
		}
	}
	
	i++;
	swap(weights[i], weights[right]);
	swap(edges[i][0], edges[right][0]);
	swap(edges[i][1], edges[right][1]);
	
	return i;
}

void quick_sort_rpiv(int* weights, int edges[CAP*CAP][2], int left, int right) 
{
	if (left < right)
	{
		int barr = partition_rpiv(weights, edges, left, right);
		quick_sort_rpiv(weights, edges, left, barr - 1);
		quick_sort_rpiv(weights, edges, barr + 1, right);
	}
	
}

//////////////////////////////////////////////////////////

void g_read(Graph* graph)
{
	// Reading the adjacency matrix of the graph
	
	scanf("%d", &(graph->noof_v));
	mat_read(graph->noof_v, graph->noof_v, graph->mat);
	for (int i = 0; i < graph->noof_v; ++i)
		graph->mat[i][i] = 0;
}

void g_sparsify_edges_and_weights(Graph* graph)
{
	int i, j, noof_v = graph->noof_v;
	graph->noof_e = 0;

	for (i = 0; i < noof_v; ++i)
		for (j = i; j < noof_v; ++j)
			if (graph->mat[i][j] > 0)
			{
				graph->edges[graph->noof_e][0] = i;
				graph->edges[graph->noof_e][1] = j;
				graph->weights[graph->noof_e] = graph->mat[i][j];
				graph->noof_e += 1;
			}

	edges_and_weights_print(graph->noof_e, graph->edges, graph->weights);
	printf("Here");
}

void g_sort_edges_by_weight(Graph* graph)
{
	quick_sort_rpiv(graph->weights, graph->edges, 0, graph->noof_e - 1);	
	edges_and_weights_print(graph->noof_e, graph->edges, graph->weights);
}

void g_kruskals_mst(Graph* graph, int src)
{
	int noof_v = graph->noof_v;
	int d_arr[noof_v + 1];
	d_construct(noof_v, d_arr);
	
	//int mst[CAP*CAP][2];
	int cur = 0, u, v, anc1, anc2;
	
	g_sparsify_edges_and_weights(graph);
	g_sort_edges_by_weight(graph);
	printf("Here");

	for(int i = 0; i < graph->noof_e; ++i)
	{
		u = graph->edges[i][0];
		v = graph->edges[i][1];
		anc1 = d_find(noof_v, d_arr, u);
		anc2 = d_find(noof_v, d_arr, v);

		if (anc1 != anc2)
		{/*
			mst[cur][0] = u;
			mst[cur][1] = v;
			cur += 1;
			*/
			d_union(noof_v, d_arr, anc1, anc2);
		}
	}	
	//mst_print(cur, mst);
}

void main()
{
	Graph graph;
	g_read(&graph);
	g_kruskals_mst(&graph, 0);	
}
